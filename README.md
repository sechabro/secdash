# ‚öîÔ∏è SecDash ‚öîÔ∏è

**A real-time, modular security dashboard for monitoring server health, malicious IP activity, and more. Built for lean self-hosting and security visibility/observability.**

![SecDash Logo](img/secdash_lh.png)


## Features
- **World Map Threat Intel**: Real-time IP tracking by country with AbuseIPDB enrichment.
- **AI Risk Analysis**: GPT 3.5-powered risk assessment for dangerous IP address activity against your server (with auto-ban for super high-risk IPs).
- **System Monitoring**: Live CPU, memory, and disk usage via `iostat`. Process info, and network connections as well.
- **Brute Force Protection**: Monitors SSH login attempts and potentially auto-bans IPs (based on AI risk assessment) using `ipset` and `iptables`.
- **Toast Alerting**: A small alert, notifying users of recently-captured IP addresses. When clicked, a message center is opened with fuller details on the IP address in question.
- **Message Center**: Archived and detailed alerts for IP addresses, including their current status on your server. 
- **Modular SSE Stream Events**: Timed real-time events that monitor live IP activity, system performance, alert generation, and user-originated processes.


---

## Stack
- **Backend**: FastAPI ¬∑ PostgreSQL ¬∑ Asyncio ¬∑ Nginx ¬∑ A little bit of Bash
- **Frontend**: Vanilla JS (ES Modules) ¬∑ Chart.js ¬∑ ECharts
- **Security**: JWT Auth (HTTP-only cookies) ¬∑ AbuseIPDB integration ¬∑ AI-based threat scoring ¬∑ ?Greynoise in the future?
- **AI**: OpenAI GPT-3.5 (for optional analysis and recommendations)


---

## üß† How It Works

SecDash streams system and security data from your VPS or self-hosted server in real-time via Server-Sent Events. It watches for:

- Incoming connections and failed logins from IP addresses.
- High-risk or repeat IPs (enriched with AbuseIPDB).
- `iostat` and `psutil` system performance metrics to detect spikes or drops.
- All currently running processes, their parent process, and the user that spawned them.


When risky IPs are identified, SecDash can:
- Auto-ban the IP if AI analysis returns matching analysis.
- Log and display alerts in the dashboard (toast alerting mentioned above)
- Recommend further action for active, yet suspicious IPs.


---

## Getting Started
- Clone this repo.
- Make a .env with the following:
```
OPENKEY001="<openai project key>"
OPENORG="<openai org key>"
IPDB="<abuseipdb api key>"
ABPWD="<database password>"
SECD="<use the value generated by this command: openssl rand -base64 32>"
```

- In `database.py`, match the below vars to your database environment:
```
DATABASE_URL = f"postgresql+asyncpg://<dbuser>:{abpwd}@localhost:5432/secdash"
TEMP_SYNC_DB_URL = f"postgresql://<dbuser>:{abpwd}@localhost:5432/secdash"
```

- Make sure your server has Python 3.12.3 installed and running.
- In your project root folder, run:
```
python -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

- Perform database migrations with `alembic upgrade head`.
- Create a temp_user with `touch secret_user.py`.
- Vim this in:
```
async def temp_user():
    from argon2 import PasswordHasher

    import schemas
    from crud import register_user
    from database import get_session

    async for session in get_session():
        psh = PasswordHasher()
        password = "your_password_here" #<-- change this
        pswd_hash_salt = psh.hash(password=password)
        user = schemas.UserReg(
            username="username_here at least 8 characters", #<--change this
            email="an_email@somedomain.computer", #<--change this
            password=pswd_hash_salt
        )
        await register_user(session=session, user=user)
        break

if __name__ == "__main__":
    import asyncio
    asyncio.run(temp_user())
```
- Run `python secret_user.py` to create the user.
- Deactivate the virtual env with `deactivate`.


- Install `npm` on your server if it isn't installed already.
- Run `npm run build`.


# IP Blacklist Setup
## [ipset & iptables]
#### ipset
- Create ipset blacklist: `ipset create blacklist hash:ip family inet hashsize 1024 maxelem 65536`.
- Save current ipset rules: `ipset save > /etc/ipset.rules`. This dumps the blacklist definition into a file called `ipset.rules`.

#### iptables
- Configure iptables to drop traffic packets from IPs in the ipset blacklist: `iptables -I INPUT -m set --match-set blacklist src -j DROP`
- Sanity check, verify: `iptables -L -n --line-numbers`
- As in `ipset` above, save the current `iptables` rules like so: `iptables-save > /etc/iptables.rules`.

## [systemd]

### STEPS:
- Create the systemd service that will restore ipset based on the rules you just created, on reboot: `touch /etc/systemd/system/ipset-restore.service`
- `vim` into the file and create the service conditions:

```
[Unit]
Description=Restore ipset rules
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c '! /sbin/ipset list blacklist > /dev/null 2>&1 && /sbin/ipset restore < /etc/ipset.rules || echo "ipset already exists, skipping restore"'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

- As above, do the same for iptables to restore on reboot: `touch /etc/systemd/system/iptables-restore.service`. Then, `vim` into the file and create the service conditions:

```
[Unit]
Description=Restore iptables firewall rules
After=network.target

[Service]
Type=oneshot
ExecStart=/sbin/iptables-restore < /etc/iptables.rules
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

- Enable the services: `systemctl enable ipset-restore.service && systemctl enable iptables-restore.service`


## Setup Confirmation:
- Reboot your server
- Run the following: `ipset list` and `iptables -L -n`. You should still see the just-created blacklist, and the DROP rule.



## Nginx Setup
- Add a config file with touch /etc/nginx/sites-available/<secdash.yourwebsite.urlhere>
- Vim this in:
```
server {
    listen 443 ssl;
    server_name secdash.yourwebsite.urlhere;

    ssl_certificate path_to_ssl_cert_here.cer;
    ssl_certificate_key path_to_private_key_here.key;
    ssl_trusted_certificate path_to_crt_bundle.crt;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
location / {
        proxy_pass http://localhost:8000/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
location ~* ^/(.*-)?stream$ {
    proxy_pass http://localhost:8000;
    proxy_http_version 1.1;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Connection '';
    proxy_buffering off;
    proxy_cache off;
    proxy_read_timeout 86400;
    proxy_send_timeout 86400;
    chunked_transfer_encoding off;
}
}
server {
    listen 80;
    server_name secdash.yourwebsite.urlhere;

    return 301 https://$host$request_uri;
}
```

- Run these commands to confirm everything is set.
```
ln -s /etc/nginx/sites-available/<secdash.yourwebsite.urlhere> /etc/nginx/sites-enabled/ <-- symlink
nginx -t <-- confirm setup is good
systemctl reload nginx
```

## SecDash SystemD Setup
- Create config file: `touch /etc/systemd/system/secdash.service`
- Vim in the following:
```
[Unit]
Description=SecDash FastAPI Runner Service
After=network.target

[Service]
User=root
WorkingDirectory=/home/github/secdash
ExecStart=/home/github/secdash/venv/bin/python -m uvicorn app:app
Restart=always
Environment=PYTHONUNBUFFERED=1
EnvironmentFile=/home/github/secdash/.env

[Install]
WantedBy=multi-user.target
```

- Finally, run the following commands:
```
systemctl daemon-reexec
systemctl daemon-reload
systemctl enable secdash
systemctl start secdash
```

- Run `journcalctl -u secdash.service -f` to watch logs.
- Go to your url, log in with the user you created, and enjoy SecDash!



---
¬© 2025 Sean ‚Ä¢ MIT License